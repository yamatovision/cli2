# プロジェクト切り替え機能の問題分析と改善設計

## 問題の本質

AppGeniusアプリケーションのプロジェクト切り替え機能において、UI上でプロジェクトの切り替えが表示上は行われているものの、実際の動作（ファイルパス参照やターミナル起動場所）では元のプロジェクト（AppGenius）を参照し続ける問題が発生しています。

### 具体的な症状

1. プロジェクト選択（selectProject）メッセージ処理が行われ、UI表示は正しく「現在のプロジェクト：SNSPOJECT」と表示されるが、実際の操作（ファイル読み込みやターミナル起動場所）ではAppGeniusが参照される
2. 例：ClaudeCodeを起動する場合、UI上は「現在のプロジェクト：SNSPOJECT」と表示されていても、実際のターミナルはAppGeniusのルートディレクトリで開かれる
3. 同様に、モックアップギャラリーを開いた場合も、表示上は別プロジェクトを選択しているにもかかわらず、AppGeniusのモックアップが表示される
4. 一部のパネルでは切り替え後のプロジェクトパスが正しく使用されるが、他のパネルでは元のプロジェクトパスが使用され続ける

## アーキテクチャの課題

コードベースの詳細な分析の結果、以下の重大な設計上の問題が見つかりました：

### 1. 単一責任原則の違反

現在のコードでは、プロジェクトパスの管理と保持が複数の場所に分散しています：

- **ProjectServiceImpl**: プロジェクト情報を管理するが、他のサービスが独自にプロジェクトパスを保持している
- **MessageDispatchServiceImpl**: メッセージングだけでなくプロジェクト選択ロジックも部分的に実装
- **FileSystemServiceImpl**: ファイル操作時に直接プロジェクトパスを参照し、独自の判断でパスを使用
- **MockupGalleryPanel**: 独自の`_projectPath`変数でパスを保持
- **ClaudeCodeLauncherService**: ターミナル起動時にパスを保持・参照
- **FileBrowser.js**: `currentPath`変数で独自にパスを保持・管理

### 2. 状態更新の不完全な伝播

- プロジェクト切り替え時に、現在のプロジェクトパスを管理すべき唯一の責任者（**ProjectServiceImpl**）の更新は正しく行われるが、他のコンポーネントへの通知が不完全
- **AppGeniusEventBus**によるイベント発行は行われているが、多くのコンポーネントがイベントを適切に購読・処理していない
- **PROJECT_SELECTED**イベントの購読が不十分で、`tabManager.js`や`fileBrowser.js`などがプロジェクトパス変更に正しく反応しない

### 3. 冗長な状態保持

- 各コンポーネントが独自のプロジェクトパス変数を保持していることで、状態の不一致が生じやすくなっている
- 例：**MockupGalleryPanel**は`_projectPath`、**MessageDispatchServiceImpl**は状態の一部として独自のパスを保持
- **stateManager.js**には冗長な状態管理処理があり、プロジェクトパスの更新が複雑になっている

## 改善設計：単一責任原則への回帰と直接接続パターン

問題解決の核心は、プロジェクト状態を「ソースオブトゥルース（単一の信頼できる情報源）」として一元管理する設計に戻し、不要な中間層を省くことです。

### 1. ユーザーから直接ProjectServiceImplへの接続

MessageDispatchServiceImplを経由せず、ユーザーのプロジェクト選択アクションを直接ProjectServiceImplに接続します：

```typescript
// ScopeManagerPanel.tsの_setupMessageHandler内で直接プロジェクト選択を処理
private _setupMessageHandler() {
  this._panel.webview.onDidReceiveMessage(async (message) => {
    // プロジェクト選択を直接処理
    if (message.command === 'selectProject') {
      try {
        const projectService = ProjectServiceImpl.getInstance();
        await projectService.selectProject(
          message.projectName,
          message.projectPath,
          message.activeTab
        );
        
        // 成功通知を送信
        this._panel.webview.postMessage({
          command: 'showSuccess',
          message: `プロジェクト「${message.projectName}」を開きました`
        });
      } catch (error) {
        // エラー処理
        Logger.error(`プロジェクト選択エラー: ${(error as Error).message}`);
        this._panel.webview.postMessage({
          command: 'showError',
          message: `プロジェクト選択に失敗しました: ${(error as Error).message}`
        });
      }
      return; // 処理終了
    }
    
    // その他のメッセージはMessageDispatchServiceで処理
    this._messageDispatchService.handleMessage(message, this._panel);
  });
}
```

### 2. ProjectServiceImpl への一元化

**ProjectServiceImpl**をプロジェクト情報の唯一の責任者として位置づけ直します：

```typescript
// ProjectServiceImplの強化
export class ProjectServiceImpl implements IProjectService {
  // 唯一の信頼できるプロジェクト状態
  private _activeProject: IProjectInfo | null = null;
  
  // すべてのコンポーネントはこのメソッドを使用して最新のパスを取得
  public getActiveProjectPath(): string {
    return this._activeProject?.path || '';
  }
  
  // プロジェクト切り替え時の動作を確実に行う
  public async selectProject(name: string, path: string, activeTab?: string): Promise<void> {
    // 既存のプロジェクトと同じ場合も、再同期を実施
    if (this._projectPath === path) {
      Logger.info(`ProjectService: 同じプロジェクトが選択されています - 再同期を実施: ${path}`);
      // このケースでも必ずイベントを発行
      this._publishProjectSelectedEvent(name, path);
      return;
    }
    
    // その他の選択処理...
    
    // 必ず明示的なイベント発行
    this._publishProjectSelectedEvent(name, path);
  }
  
  // イベント発行を確実に行うヘルパーメソッド
  private _publishProjectSelectedEvent(name: string, path: string): void {
    try {
      const eventBus = AppGeniusEventBus.getInstance();
      eventBus.emit(
        AppGeniusEventType.PROJECT_SELECTED,
        { id: this._activeProject?.id, path: path, name: name },
        'ProjectService',
        this._activeProject?.id || path
      );
      Logger.info(`ProjectService: プロジェクト選択イベントを発行: ${name}, ${path}`);
    } catch (error) {
      Logger.error(`ProjectService: イベント発行失敗: ${error}`);
    }
  }
}
```

### 3. 他のコンポーネントでの参照方法の統一

すべてのコンポーネントが**独自にプロジェクトパスを保持せず**、必要な時に`ProjectServiceImpl`から最新の値を取得するように修正します：

```typescript
// 各コンポーネントでの参照方法の例（MockupGalleryPanelなど）
export class SomeComponent {
  // 直接パスを保持しない
  // private _projectPath: string; <- 削除
  
  // 代わりに必要な時点で毎回取得
  private _getCurrentProjectPath(): string {
    const projectService = ProjectServiceImpl.getInstance();
    return projectService.getActiveProjectPath();
  }
  
  // ファイル操作などの時に使用
  private async _loadSomeFile(): Promise<void> {
    const projectPath = this._getCurrentProjectPath();
    const filePath = path.join(projectPath, 'some/file/path.md');
    // ファイル読み込み処理...
  }
}
```

### 4. イベント購読の徹底

すべての関連コンポーネントが明示的にプロジェクト関連イベントを購読するよう修正します：

```typescript
// 各コンポーネントでのイベント購読（MockupGalleryPanelなど）
private _setupEventSubscriptions(): void {
  const eventBus = AppGeniusEventBus.getInstance();
  
  // プロジェクト選択イベントを明示的に購読
  this._disposables.push(
    eventBus.onEventType(AppGeniusEventType.PROJECT_SELECTED, (event) => {
      if (event.data && event.data.path) {
        Logger.info(`プロジェクト選択イベントを受信: ${event.data.name}, ${event.data.path}`);
        
        // UIの更新
        this._updateUIForProject(event.data.name, event.data.path);
        
        // 各種リソースの更新（ファイル読み込みなど）
        this._refreshResourcesForProject(event.data.path);
      }
    })
  );
}
```

### 5. 起動時の状態同期の実装

各パネルが表示される際に、必ずプロジェクト状態と同期するよう実装します：

```typescript
// 各パネルの表示/初期化時
public reveal(): void {
  // パネルを表示
  this._panel.reveal();
  
  // 現在の正しいプロジェクト情報で同期
  const projectService = ProjectServiceImpl.getInstance();
  const activeProject = projectService.getActiveProject();
  
  if (activeProject) {
    // UIの更新
    this._updateUIForProject(activeProject.name, activeProject.path);
    
    // 各種リソースの更新
    this._refreshResourcesForProject(activeProject.path);
  }
}
```

### 6. 明示的なパス取得と検証

操作の都度、最新のプロジェクトパスを取得するよう修正します：

```typescript
// これまで：クラス変数に保存したパスを使用
const filePath = path.join(this._projectPath, 'docs', 'requirements.md');

// 改善後：操作のたびに最新のパスを取得
private _getDocumentPath(documentName: string): string {
  const projectService = ProjectServiceImpl.getInstance();
  const projectPath = projectService.getActiveProjectPath();
  
  // 検証を含める
  if (!projectPath) {
    Logger.warn(`プロジェクトパスが存在しません: ${documentName}を読み込めません`);
    throw new Error('プロジェクトが選択されていません');
  }
  
  return path.join(projectPath, 'docs', documentName);
}

// 使用例
const requirementsPath = this._getDocumentPath('requirements.md');
```

## 改善後の情報伝播フロー

改善後のプロジェクト切り替え情報伝播フローは以下のようになります：

```
ユーザーがプロジェクト選択 → ScopeManagerPanel.ts（直接ハンドリング）
                     → ProjectServiceImpl.selectProject(name, path)を呼び出し
                        → ProjectServiceImplが内部状態を更新
                        → ProjectServiceImplがPROJECT_SELECTEDイベントを発行 
                           → 必要なコンポーネントがイベントを購読して反応:
                              → ScopeManagerPanelがUI更新
                              → MockupGalleryPanelがUIとリソースを更新
                              → ClaudeCodeLauncherServiceが必要時にパスを取得
                              → その他のUIコンポーネントが更新
```

この直列的なフローにより、MessageDispatchServiceImplという中間層を省くことができ、情報伝播がより直感的で信頼性の高いものになります。

## 特に重点的に修正すべきコンポーネント

1. **ScopeManagerPanel**: ユーザーのプロジェクト選択を直接ProjectServiceImplに接続するよう修正
2. **ClaudeCodeLauncherService**: ターミナル起動時に必ず最新のプロジェクトパスを取得するよう修正
3. **MockupGalleryPanel**: パネル表示時にProjectServiceImplから最新パスを取得し、自身のパス変数を使わないよう修正
4. **FileSystemServiceImpl**: ファイル操作時に都度ProjectServiceImplから最新パスを取得するよう修正
5. **stateManager.js**: WebView側でも同様の原則を適用し、状態更新時の競合を防止
6. **tabManager.js**: プロジェクトパス変更に適切に反応するようイベント購読を実装
7. **fileBrowser.js**: 独自のパス管理をやめ、サーバーサイドと同期するよう修正

## 具体的な実装ステップ

1. **ScopeManagerPanelの修正**:
   - プロジェクト選択メッセージを直接処理するロジックを追加
   - MessageDispatchServiceImplへの委譲を省く

2. **ProjectServiceImpl の強化**:
   - イベント発行の確実な実行
   - 状態変更時の明示的なログ記録
   - すべてのプロジェクトパス取得をこのクラスに集中

3. **MessageDispatchServiceImpl の修正**:
   - プロジェクト選択関連の重複ロジックを削除
   - 'selectProject'メッセージハンドラ登録を削除

4. **FileSystemServiceImpl の修正**:
   - 各メソッド内でProjectServiceImplから最新パスを取得するよう修正
   - 特に`getDirectoryStructure`、`getProgressFilePath`などで必ず最新パスを使用

5. **パネルコンポーネントの修正**:
   - 独自のプロジェクトパス変数を削除
   - 操作時の明示的なパス取得の実装
   - イベント購読の徹底

6. **WebViewコンポーネントの修正**:
   - fileBrowser.jsの`currentPath`変数管理を見直し
   - tabManager.jsでプロジェクト変更イベントを適切に処理
   - stateManager.jsでの冗長な状態管理コードを簡素化

7. **イベント伝播メカニズムの強化**:
   - 重要な状態変更イベントを確実に発行
   - すべての関連コンポーネントでのイベント購読の確認
   - PROJECT_SELECTEDとPROJECT_UPDATEDのイベント標準化

## 削除可能なコード

コードベースの詳細な分析の結果、以下のコードが安全に削除または修正可能であることが特定されました：

### 1. MessageDispatchServiceImpl のプロジェクト選択関連コード

```typescript
// MessageDispatchServiceImpl.ts から完全に削除可能なコード

// selectProject メソッド全体を削除（941-1058行目）
public async selectProject(panel: vscode.WebviewPanel, projectName: string, projectPath: string, activeTab?: string): Promise<boolean> {
  // 削除対象: 941-1058行目の処理全体
}

// プロジェクト選択ハンドラ登録も削除
this.registerHandler('selectProject', async (message: Message, panel: vscode.WebviewPanel) => {
  if (message.projectName && message.projectPath) {
    await this.selectProject(panel, message.projectName, message.projectPath, message.activeTab);
  } else {
    Logger.warn('MessageDispatchServiceImpl: selectProjectメッセージに必要なパラメータがありません');
    this.showError(panel, 'プロジェクト選択に必要な情報が不足しています');
  }
});
```

### 2. MockupGalleryPanel のプロジェクトパス関連コード

```typescript
// MockupGalleryPanel.ts の修正対象コード

// 削除対象: クラス変数としてのプロジェクトパス保持
private _projectPath: string; // 削除

// 修正対象: _updateProjectPath メソッド - 完全に書き換え
private _updateProjectPath(projectPath: string): void {
  // 削除: 以前のパスを保存
  // 削除: this._projectPath = projectPath; などの独自変数への保存

  // 代わりに必要な初期化処理のみを行い、パス自体は保持しない
  // 例: ストレージサービスの初期化
  this._storage.initializeWithPath(projectPath);
  
  // UI表示の更新
  this._update();
  
  // モックアップを再読み込み (内容の更新)
  this._handleLoadMockups();
  
  // ...その他の必要な処理（ファイルブラウザリフレッシュなど）
}

// 削除対象: _getDefaultProjectPath メソッド - プロジェクトパスの決定は常にProjectServiceに委譲
private _getDefaultProjectPath(): string {
  // 削除対象: 232-330行目の処理全体
  // 代わりに以下のような単純な委譲処理を実装
  const projectService = ProjectServiceImpl.getInstance();
  return projectService.getActiveProjectPath();
}

// 修正対象: パスが必要な各メソッド
private async _handleLoadMockups(): Promise<void> {
  try {
    // 実行時にその都度ProjectServiceから最新パスを取得
    const projectService = ProjectServiceImpl.getInstance();
    const currentProjectPath = projectService.getActiveProjectPath();
    
    // 例：ストレージサービスを再初期化
    this._storage.initializeWithPath(currentProjectPath);
    
    const mockups = this._storage.getAllMockups();
    // ... 以下処理は同じ
  } catch (error) {
    // ... エラー処理
  }
}
```

### 3. ClaudeCodeLauncherService のプロジェクトパス参照

現在の`ClaudeCodeLauncherService`は既に`CoreLauncherService`へのラッパーとして機能しているため、大きな修正は不要ですが、`SpecializedLaunchHandlers`での具体的なパス利用部分には注意が必要です：

```typescript
// SpecializedLaunchHandlers.ts 内の修正対象コード

// launchWithPrompt メソッド内の修正ポイント
public async launchWithPrompt(options: PromptExecutionOptions): Promise<{ success: boolean; error?: string; }> {
  try {
    const { promptFilePath, projectPath, ... } = options;
    
    // 修正対象: プロジェクトパスの確認
    // 代わりに、常に最新のプロジェクトパスをProjectServiceから取得し直す処理を追加
    const projectService = ProjectServiceImpl.getInstance();
    const currentProjectPath = projectService.getActiveProjectPath();
    
    // 渡されたパスと異なる場合は警告ログを出力
    if (projectPath !== currentProjectPath) {
      Logger.warn(`渡されたプロジェクトパス(${projectPath})と現在のアクティブパス(${currentProjectPath})が異なります。アクティブパスを使用します。`);
    }
    
    // 以降は currentProjectPath を使用
    // ...

    // ターミナルの作成時はアクティブパスを使用
    const terminal = await this.terminalService.createConfiguredTerminal({
      cwd: currentProjectPath,
      ...terminalOptions
    });
    
    // ... 以下処理は同じ
  } catch (error) {
    // ... エラー処理
  }
}
```

### 4. stateManager.js での冗長な状態管理

```javascript
// stateManager.js 内の修正対象コード

// 削除対象1: handleUpdateState メソッド内の複雑なロジック (102-156行)
// 現在の実装:
handleUpdateState(data) {
  // 削除可能: 不要なログ出力
  console.log('状態更新受信: データ処理開始');

  // 削除可能: 競合状態管理の複雑な処理
  if (this._isProcessingStateUpdate) {
    console.log('状態更新: 別の更新処理が進行中のため遅延実行します');
    // 後で実行するようにキューに入れる
    setTimeout(() => this.handleUpdateState(data), 100);
    return;
  }

  this._isProcessingStateUpdate = true;

  try {
    // 削除可能: 不要な条件チェックと冗長な処理
    const prevState = this.vscode.getState() || {};
    const newState = { ...prevState, ...data };
    this.setState(newState, false);

    // 削除可能: マークダウン処理の複雑なロジック（他のコンポーネントに移動）
    if (data.scopeProgressMarkdown &&
        data.scopeProgressMarkdown !== prevState.scopeProgressMarkdown) {
      // ... マークダウン更新イベント処理
    } else if (data.progressFilePath &&
              !data.scopeProgressMarkdown &&
              data.progressFilePath !== prevState.lastRequestedProgressFile) {
      // ... ファイル取得メッセージ送信
    }

    this._notifyListeners();
  } finally {
    // 削除可能: 不要なフラグ管理
    this._isProcessingStateUpdate = false;
  }
}

// シンプル化した版:
handleUpdateState(data) {
  if (!data) return;
  this.setState(data);
}

// 削除対象2: syncProjectState メソッド内の冗長なコード (162-244行)
// 現在の実装:
syncProjectState(project) {
  // 削除可能: 不要なログ出力
  console.log('ProjectManagementServiceからプロジェクト状態を同期:', project);

  // 削除可能: 複雑な同期スロットリング処理
  const now = Date.now();
  const lastSyncTime = state.lastProjectSyncTime || 0;
  const lastSyncId = state.lastSyncedProjectId;
  const syncThreshold = 300;
  if (now - lastSyncTime < syncThreshold && lastSyncId === project.id) {
    console.log(`プロジェクト同期をスキップ: 直近(${now - lastSyncTime}ms前)に同期済み`);
    return;
  }

  // 削除可能: 冗長な状態更新
  const newState = {
    ...state,
    lastProjectSyncTime: now,
    lastSyncedProjectId: project.id,
    activeProjectName: project.name,
    activeProjectPath: project.path
  };

  // 削除可能: 複雑なタブ状態同期ロジック
  if (project.metadata && project.metadata.activeTab) {
    newState.activeTab = project.metadata.activeTab;
  } else if (!newState.activeTab) {
    newState.activeTab = 'scope-progress';
  }

  // 削除可能: 冗長なイベント発行処理
  if (project.name) {
    const nameEvent = new CustomEvent('project-name-updated', {
      detail: { name: project.name }
    });
    document.dispatchEvent(nameEvent);
  }

  // 削除可能: パス情報の重複処理
  if (project.path) {
    const isNewProject = state.lastSyncedProjectId !== project.id;
    const isExplicitRefresh = !!project.forceRefresh;

    const pathData = { /* ... */ };

    // ... プロジェクトパス更新イベント

    // 削除可能: 自動ファイル読み込み処理
    this.sendMessage('getMarkdownContent', { /* ... */ });
  }

  // 削除可能: 冗長なタブ状態処理とタイミング処理
  if (project.metadata && project.metadata.activeTab) {
    const activeTabId = project.metadata.activeTab;

    // ... タブ状態更新イベント

    // 削除可能: setTimeout による遅延処理と条件分岐
    setTimeout(() => {
      if (activeTabId === 'scope-progress') {
        // ... 進捗状況ファイル再読み込み
      } else if (activeTabId === 'requirements') {
        // ... 要件定義ファイル読み込み
      } else if (activeTabId === 'file-browser') {
        // ... ファイルブラウザ更新
      }
    }, 100);
  }
}

// シンプル化した版:
syncProjectState(project) {
  if (!project || !project.path) return;

  // 最小限の状態更新
  this.setState({
    activeProjectName: project.name,
    activeProjectPath: project.path,
    activeTab: project.metadata?.activeTab || 'scope-progress'
  });

  // 単一のイベント発行
  document.dispatchEvent(new CustomEvent('project-updated', {
    detail: { project }
  }));
}

// 削除対象3: restoreProjectState メソッドの冗長な部分 (292-353行)
restoreProjectState() {
  // ...省略...

  // 削除可能: setTimeout による遅延処理
  setTimeout(() => {
    try {
      // 削除可能: 不要な状態再取得
      const updatedState = this.getState();
      const { activeProjectName, activeProjectPath } = updatedState;

      // 削除可能: 冗長なログ出力
      console.log('プロジェクト状態の復元を試みます:', {
        activeProjectName,
        activeProjectPath
      });

      // 削除可能: 二重イベント発行
      const nameEvent = new CustomEvent('project-name-updated', {
        detail: { name: activeProjectName }
      });
      document.dispatchEvent(nameEvent);

      const pathEvent = new CustomEvent('project-path-updated', {
        detail: {
          projectPath: activeProjectPath,
          statusFilePath: activeProjectPath ? `${activeProjectPath}/docs/SCOPE_PROGRESS.md` : '',
          statusFileExists: true,
          forceRefresh: false
        }
      });
      document.dispatchEvent(pathEvent);

    } catch (error) {
      console.error('プロジェクト状態の完全復元中にエラーが発生しました:', error);
    }
  }, 100);
}

// シンプル化した版:
restoreProjectState() {
  const state = this.getState();

  // 再利用可能なsyncProjectStateを呼び出す
  if (state.activeProjectName && state.activeProjectPath) {
    this.syncProjectState({
      name: state.activeProjectName,
      path: state.activeProjectPath,
      metadata: { activeTab: state.activeTab }
    });
  }
}
```

stateManager.jsから削除・修正することで、コード量を約50%削減でき、予測可能で管理しやすいコードになります。削除する部分の主なカテゴリは:

1. 冗長なログ出力（デバッグ用途のみで、本質的な機能に不要）
2. 複雑なタイミング制御（setTimeout, _isProcessingStateUpdateフラグなど）
3. 多重のイベント発行（project-name-updated, project-path-updated, tab-state-updatedなど）
4. 冗長な条件分岐（特にsyncProjectState内のタブ種類による処理分岐）
5. ハードコードされたパス（特にdocs/SCOPE_PROGRESS.mdなど）

全体で約100行のコード削減が見込めます。

### 5. FileSystemServiceImpl のプロジェクトパス直接参照

```typescript
// FileSystemServiceImpl.ts から修正対象のコード

// 修正対象: パスが直接引数で渡されている
public getProgressFilePath(projectPath: string): string {
  if (!projectPath) {
    throw new Error('プロジェクトパスが指定されていません');
  }
  
  // docs/SCOPE_PROGRESS.mdというパスを構築
  const docsDir = path.join(projectPath, 'docs');
  return path.join(docsDir, 'SCOPE_PROGRESS.md');
}

// 代わりに以下のように修正：
public getProgressFilePath(): string {
  // ProjectServiceImplから最新のパスを取得
  const projectService = ProjectServiceImpl.getInstance();
  const projectPath = projectService.getActiveProjectPath();
  
  if (!projectPath) {
    throw new Error('有効なプロジェクトが選択されていません');
  }
  
  const docsDir = path.join(projectPath, 'docs');
  return path.join(docsDir, 'SCOPE_PROGRESS.md');
}
```

### 6. fileBrowser.js でのプロジェクトパス管理

```javascript
// fileBrowser.js 内の修正対象コード

// 削除対象: 独自のパス変数
constructor() {
  this.currentPath = null; // 削除または使用方法変更
  // ...
}

// 修正対象: ディレクトリリスト要求処理
_requestDirectoryListing(path) {
  // 削除: パスをクラス変数に保存
  this.currentPath = directoryPath; // この行は削除
  
  // 代わりに毎回サーバーから最新のパスを取得する形に変更
}
```

### 7. tabManager.js でのプロジェクト変更検知不足

```javascript
// tabManager.js 内の追加実装

// プロジェクト選択変更イベントの購読を追加
constructor() {
  // 既存の初期化コード...
  
  // プロジェクト変更イベントの購読を追加
  window.addEventListener('message', (event) => {
    const message = event.data;
    if (message.command === 'project-selected' || message.command === 'project-updated') {
      // プロジェクトが変更された場合の処理
      this._handleProjectChanged(message.data);
    }
  });
}

// プロジェクト変更時のハンドラを実装
_handleProjectChanged(projectData) {
  // プロジェクト変更時に必要なタブ状態更新を実行
  if (projectData && projectData.path) {
    // 現在のアクティブタブを保持
    const currentTabId = this.activeTab;
    
    // タブコンテンツを最新のプロジェクト情報で更新
    this._refreshTabContents(projectData.path);
  }
}
```

## プロジェクトとタブ状態管理の問題

プロジェクト切り替えの問題には、タブ状態管理の複雑さも大きく関わっています。現在の実装では、プロジェクトとタブの状態管理が異なるサービスに分散し、データフローの混乱を招いています。

### タブ状態管理に関する現在の設計問題

1. **複数の「信頼できる情報源」の存在**:
   - `TabStateServiceImpl`は独自のMap（`_projectTabStates`）でプロジェクトとタブの関係を保持
   - `ProjectServiceImpl`もプロジェクトメタデータにタブ情報を保存
   - これらの状態が同期しないと予測不能な動作が発生

2. **間接的なイベント通信チェーン**:
   - WebUIで「タブ選択」→ `'saveTabState'`メッセージ送信 → `TabStateServiceImpl` → `ProjectServiceImpl`
   - `TabStateServiceImpl`は`'tab-state-saved'`イベントを発行
   - `ProjectServiceImpl`は`'PROJECT_UPDATED'`イベントを発行
   - コンポーネントは複数のイベントタイプを監視しなければならない

3. **プロジェクト切り替え時のタブ状態同期問題**:
   - プロジェクト切り替え時にタブ状態が適切に切り替わらない可能性がある
   - コンポーネントが独立して更新されるため、状態の一貫性が保証されない

### タブ状態管理に関する削除可能なコード

```typescript
// TabStateServiceImpl.ts から削除可能なコード

// 1. 独自のプロジェクト-タブ状態Mapの削除（完全に削除可能）
private _projectTabStates: Map<string, string> = new Map();

// 2. getActiveTab メソッド - Project側でこの情報を保持するため不要
public getActiveTab(projectId: string): string | undefined {
  return this._projectTabStates.get(projectId);
}

// 3. saveTabState メソッドの簡素化 - Map保持の削除とProjectServiceへの委譲のみ
public async saveTabState(projectId: string, tabId: string): Promise<void> {
  try {
    Logger.debug(`TabStateServiceImpl: タブ状態を保存します: プロジェクト=${projectId}, タブ=${tabId}`);
    
    // 削除: this._projectTabStates.set(projectId, tabId);
    
    // プロジェクトサービスが利用可能な場合、メタデータに保存
    if (this._projectService) {
      await this._projectService.saveTabState(projectId, tabId);
    }
    
    // イベント発行処理は残す
    // ...
  } catch (error) {
    // ...
  }
}
```

```javascript
// tabManager.js 内の削除可能なコード

// 削除対象: 独自のタブ状態追跡処理
let activeTabId = null; // 削除可能
let tabHistory = []; // 削除可能

// 削除/簡素化対象: タブ状態を直接管理せず、バックエンドからの情報に基づいて表示を更新するよう変更
function selectTab(tabId) {
  // 削除: activeTabId = tabId;
  // 削除: tabHistory.push(tabId);
  
  // 保持: WebView → Extension側への通知
  vscode.postMessage({
    command: 'selectTab',
    tabId: tabId
  });
}
```

### タブ状態管理の改善設計

1. **TabStateServiceImplの簡素化**:
   - 独自のMap（`_projectTabStates`）を削除し、`ProjectServiceImpl`に完全に委譲
   - タブ操作は記録するが、状態保持は`ProjectServiceImpl`のみに一元化

2. **イベント発行の一元化**:
   - タブ状態変更時に`ProjectServiceImpl`から単一のイベントタイプを発行
   - すべてのコンポーネントはこの統一されたイベントを購読

3. **WebUIとバックエンドの同期強化**:
   - パネル表示時に明示的に最新のプロジェクト・タブ状態を取得
   - タブ状態はプロジェクト情報の一部として一貫して扱う

## イベントシステムの標準化と削除可能なコード

現在のコードベースでは、プロジェクト状態の変更を通知するために`PROJECT_SELECTED`と`PROJECT_UPDATED`の2つのイベントタイプが使用されています。このような複数イベントタイプの使用は、冗長なコードと状態管理の複雑さを生み出す原因の一つです。

### イベント標準化によって削除可能なコード

#### 1. AppGeniusEventBus.ts で削除可能なコード

```typescript
// PROJECT_SELECTEDイベントタイプを削除し、PROJECT_UPDATEDのみに標準化
export enum AppGeniusEventType {
  // 削除: PROJECT_SELECTED = 'project-selected', 
  PROJECT_UPDATED = 'project-updated',
  // ...その他のイベントタイプ
}
```

#### 2. ProjectServiceImpl.ts での重複イベント発行コード

```typescript
// 削除可能: PROJECT_SELECTEDイベント発行（407-415行）
try {
  const eventBus = AppGeniusEventBus.getInstance();
  eventBus.emit(
    AppGeniusEventType.PROJECT_SELECTED,  // 削除可能
    { id: projectId, path: projectPath, name: projectName },
    'ProjectService',
    projectId || projectPath
  );
  Logger.info(`ProjectService: プロジェクト選択イベントを発行: ${projectName}, ${projectPath}`);
} catch (error) {
  Logger.warn(`ProjectService: イベント発行に失敗しました: ${error}`);
}

// 同様に575-586行、793-804行の重複コードも削除可能
```

#### 3. MessageDispatchServiceImpl.ts での重複イベント処理

```typescript
// 削除可能: 重複するイベント発行（146-149行など）
this._eventBus.publish(AppGeniusEventType.PROJECT_UPDATED, {
  command: message.command,
  success: true
}, 'MessageDispatchService');

// 同様に216-222行、230-235行、246-250行も削除/簡素化可能
```

#### 4. 複数コンポーネントでの重複購読コード

```typescript
// 削除可能: 複数のイベント購読（ProjectServiceImplの98-114行など）
this._disposables.push(
  eventBus.onEventType(AppGeniusEventType.PROJECT_SELECTED, async (event) => {
    // プロジェクト選択処理...
  })
);

// 147-163行、183-199行のイベント購読も統合可能
```

#### 5. stateManager.js での変換コード

```javascript
// 削除/簡素化可能: 異なるイベント形式対応のための変換コード（225-243行）
const pathData = {
  projectPath: project.path,
  statusFilePath: project.path ? `${project.path}/docs/SCOPE_PROGRESS.md` : '',
  statusFileExists: true,
  forceRefresh: isNewProject || isExplicitRefresh
};
```

### イベント標準化の設計提案

1. **単一のイベントタイプに統合**:
   ```typescript
   // 標準化されたイベント発行
   eventBus.emit(
     AppGeniusEventType.PROJECT_UPDATED,
     { 
       id: projectId, 
       path: projectPath, 
       name: projectName, 
       metadata: metadata,
       type: 'selected'  // アクションタイプ識別子
     },
     'ProjectService',
     projectId
   );
   ```

2. **統一されたペイロード形式の定義**:
   ```typescript
   interface ProjectEventPayload {
     id: string;
     path: string;
     name: string;
     metadata?: any;
     type: 'created' | 'selected' | 'updated' | 'removed';
     timestamp: number;
   }
   ```

3. **イベントリスナーの簡素化**:
   ```typescript
   eventBus.onEventType(AppGeniusEventType.PROJECT_UPDATED, (event) => {
     if (!event.data) return;
     
     switch (event.data.type) {
       case 'selected':
         // プロジェクト選択処理
         break;
       case 'updated':
         // メタデータ更新処理
         break;
       case 'created':
         // プロジェクト作成処理
         break;
       case 'removed':
         // プロジェクト削除処理
         break;
     }
   });
   ```

この標準化により、総計約195行のコードが削除・簡素化可能です：
- MessageDispatchServiceImpl.ts: 約100行
- ProjectServiceImpl.tsとProjectService.ts: 約50行
- stateManager.js: 約30行
- scopeManager.js: 約15行

## 潜在的なリスクと追加対策

1. **初期化順序の明確化**: ProjectServiceImplが他のコンポーネントより先に初期化される仕組みを確保する

2. **エラー処理の強化**: プロジェクトパスが存在しない場合の明確なエラー処理を追加し、ユーザーに適切なフィードバックを提供する

3. **タイミング問題の対策**: 急速なプロジェクト切り替えによる競合状態を避けるため、debounce機能などを検討する

4. **イベント標準化の段階的導入**: イベント統合は影響範囲が広いため、段階的な移行計画を検討する

5. **全コンポーネントの確認**: 設計文書は主要コンポーネントのみ言及しているため、他のUIコンポーネントも同様の対応が必要か確認する

## まとめ

この問題の本質は「単一責任原則からの逸脱」と「状態の分散管理」にあります。解決策は新しいレイヤーを追加することではなく、むしろ原則に立ち返り、責任の明確化と一元管理を徹底することです。プロジェクトパスとタブ状態の管理を完全にProjectServiceImplに一元化し、不要な中間層や冗長なコードを削除することで、データフローがシンプルで追跡しやすくなります。

諸悪の根源は複数箇所に散在する冗長なコードと状態管理です。これらを大胆に削除し、「単一の信頼できる情報源」パターンを徹底することで、プロジェクト切り替え機能の信頼性と一貫性が向上します。ProjectServiceImplを唯一の状態管理者として明確に位置づけ、すべてのコンポーネントがそこから最新情報を取得する設計に統一することで、コードベースはよりメンテナンス性が高く、安定した動作を示すようになるでしょう。