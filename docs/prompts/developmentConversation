

// プロンプトURLリスト - developmentway.mdに基づいた15個のプロンプト
const promptUrls = [
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/cdc2b284c05ebaae2bc9eb1f3047aa39", // 要件定義
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/9575d0837e6b7700ab2f8887a5c4faec", // システムアーキテクチャ
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/8cdfe9875a5ab58ea5cdef0ba52ed8eb", // モックアップ作成
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/f0f6805b80ae32f3846c35fe9df4eefe", // データモデル統合
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/bbc6e76a5f448e02bea16918fa1dc9ad", // データモデル精査
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/50eb4d1e924c9139ef685c2f39766589", // 環境変数収集
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/44b995b91e9879080c4e0169e7a51c0e", // 認証システム
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/612fc1991ca477744c4544255d40fe0b", // デプロイ設定
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/e6167ac13d15f778c0cae369b0068813", // GitHub管理
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/b168dcd63cc12e15c2e57bce02caf704", // 実装タスク分析
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/868ba99fc6e40d643a02e0e02c5e980a", // スコープ実装
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/247df2890160a2fa8f6cc0f895413aed", // テスト管理
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/942ec5f5b316b3fb11e2fd2b597bfb09", // デバッグ探偵
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/8c09f971e4a3d020497eec099a53e0a6", // 追加機能実装
  "https://appgenius-portal-test-235426778039.asia-northeast1.run.app/api/prompts/public/af9d922c29beffe1224ac6236d083946"  // リファクタリング
];


今まで私がClaudeCodeで開発をしてきて非技術者でも理想のアプリケーションを作成することを実現してきた上で重要だったものが
・mockups
・要件定義書



基本的にこの流れは、
#1：まず完璧なモックアップを作成する
#2：データモデルを作成する
#3：API仕様書を完成させる
#4：バックエンドを作成する
#5：バックエンドテストを行う
#6：フロントエンドのモックアップをAPIで連携させて本番で動くものにする

といった形になっています。

そして、このCURRENT_STATUSでは今タスクリストのような役割を入れています。

つまり

要件定義書で全体的なプロジェクト構造や各種ドキュメントのリンクを掲載させる場所にしておいていいと思うんですがこの量は膨大です。
なので例えばページ#1をとりかかるとしたらこのページ#1のタスクリストをCURRENT_STATUSにいれて（参考資料情報も含めて）それでAIの実装はCURRENT_STATUSを参照し、ページ#1が完了したら要件定義書も更新を入れるみたいな流れがいいかなと思っていますがどう思いますか？
つまり、要件定義書は全スコープになるので非常に大きく実際の実装になるとスコープを切り出した範囲のタスクリストやコンテクスト情報をCURRENT_STATUS(別名にしてもいいけど)に反映させてそれで更新していくイメージ



 お考えのアプローチは非常に合理的です。大規模プロジェクトを効率的に進めるためには、全体像と現在のフォーカス領域を明確に分けることが重要です。

  提案するアプローチ

  1. 要件定義書（requirements.md）:
    - プロジェクト全体の構造と全スコープを記述
    - 各ページ/機能への参照リンクを含む
    - あまり頻繁に更新しない「マスタードキュメント」として位置づけ
    - 実装完了時に反映する進捗の記録場所
  2. 現況文書（CURRENT_STATUS.md または ACTIVE_SCOPE.md）:
    - 現在取り組んでいるスコープのみに焦点を当てる
    - ページ#1などの具体的な実装タスクリスト
    - 必要な参考資料やAPIリンク
    - 進行中の実装状況の詳細を記録
    - AIが主に参照して作業を進めるドキュメント

  このアプローチの利点:

  1. コンテキスト効率化: AIのコンテキストウィンドウを効率的に使用可能
  2. 焦点の明確化: 現在実装中の機能に集中できる
  3. 分業の容易化: 複数AIが同時に異なるスコープに取り組む際に混乱が少ない
  4. 進捗管理: 細かい進捗が追跡しやすい

  例えば、irohaの例のように、CURRENT_STATUS.mdを「実装マスターインデックス」として、現在のフォーカス領域（例：SuperAdmin管理サイト）だけの詳細タスクリストを掲載し、
  他の領域はより簡略化した形で状態だけを示すといった形式が効果的でしょう。

  一つのスコープが完了したら、次のスコープに移行する際に:
  1. 完了したスコープの内容を要件定義書に反映
  2. CURRENT_STATUS.mdを次のスコープの詳細で更新

  名称については、「ACTIVE_SCOPE.md」や「CURRENT_IMPLEMENTATION.md」など、その文書の目的をより明確に表す名前に変更することも検討する価値があります。




 理想的な現況文書（CURRENT_STATUS.md）の構造

  # 現在の実装スコープ: [機能名/ページ名]

  ## 1. 基本情報

  - **スコープID**: SCOPE-123
  - **優先度**: 高
  - **担当**: スコープ実装アシスタント (#11)
  - **ステータス**: 実装中 (60% 完了)
  - **開始日**: 2025-05-05
  - **目標完了日**: 2025-05-10
  - **前提条件**: 認証システム実装完了

  ## 2. 実装概要

  [この機能の目的と重要性の簡潔な説明。実装することで得られる価値を明確に]

  ## 3. 参照ドキュメント

  - **要件定義**: [requirements.md#section-123](/docs/requirements.md#section-123)
  - **モックアップ**: [admin-dashboard.html](/mockups/admin-dashboard.html)
  - **API仕様**: [admin.md](/docs/api/admin.md)
  - **データモデル**: [admin-model.md](/docs/data_models/admin-model.md)
  - **実装ガイド**: [admin-dashboard.md](/docs/implementation/admin-dashboard.md)

  ## 4. 依存関係

  - **前提となる機能**: 認証システム、ユーザー管理
  - **影響を与える機能**: レポート機能、通知システム
  - **外部サービス依存**: Firebase Authentication

  ## 5. データフロー

  [ユーザー認証] → [権限確認] → [ダッシュボードデータ取得] → [UI表示]
                                ↑
                      [外部APIデータ同期]

  ## 6. タスクリスト

  ### バックエンド実装

  - [x] **BE-1**: ダッシュボードデータ取得APIエンドポイント実装
    - 完了日: 2025-05-06
    - 参照: [dashboard.controller.ts](/server/src/controllers/dashboard.controller.ts)
    - テスト: [dashboard.test.ts](/server/src/tests/api/dashboard.test.ts)

  - [ ] **BE-2**: データ集計サービス実装 (進行中)
    - 担当: データモデル統合 (#4)
    - 目標: 2025-05-07
    - 参照: [aggregation.service.ts](/server/src/services/aggregation.service.ts)

  - [ ] **BE-3**: 権限ベースのデータフィルタリング実装
    - 依存: BE-1, BE-2
    - 目標: 2025-05-08

  ### フロントエンド実装

  - [ ] **FE-1**: ダッシュボードコンポーネント作成
    - 目標: 2025-05-08
    - 参照: モックアップセクション #3.2

  - [ ] **FE-2**: APIとの連携実装
    - 依存: BE-1, FE-1
    - 目標: 2025-05-09

  - [ ] **FE-3**: インタラクティブチャート実装
    - 依存: FE-2
    - 目標: 2025-05-09

  ### テストとドキュメント

  - [ ] **TEST-1**: 全APIエンドポイントの統合テスト
    - 依存: すべてのBEタスク
    - 目標: 2025-05-10

  - [ ] **DOC-1**: APIドキュメント更新
    - 依存: すべてのBEタスク
    - 目標: 2025-05-10

  ## 7. 実装上の注意点

  - 権限チェックを各APIエンドポイントで徹底すること
  - データ集計は非同期処理で実行し、UI応答性を維持すること
  - チャートコンポーネントはモバイル対応を考慮すること

  ## 8. 実装状況の更新履歴

  - **2025-05-06**: BE-1完了、BE-2開始
  - **2025-05-05**: スコープ実装開始

  実装者の視点からの重要ポイント

  上記のフォーマットが効果的な理由：

  1. コンテキストの即時把握:
    - どの機能を実装するのか、なぜそれが必要なのかが明確
    - 必要な参照ドキュメントへのリンクが直接提供されている
  2. 依存関係の明示:
    - 何に依存しているか、何に影響を与えるかが明確
    - データフローが視覚的に表現されている
  3. 細分化されたタスクリスト:
    - バックエンド/フロントエンド/テストのカテゴリ分け
    - 各タスクの依存関係と目標日が明記
    - 進捗状況がチェックボックスで視覚的に把握可能
  4. 実装の指針:
    - 具体的な注意点が明記されており、潜在的な問題を事前に回避可能
  5. 更新履歴:
    - 進捗の履歴が時系列で確認できる

  私が実装者として最も重視する情報は：
  - 具体的なタスク定義と優先順位
  - 必要なドキュメントへの直接リンク
  - 依存関係と前提条件
  - 実装時の具体的な注意点
  - 現在のステータスと進捗

  このフォーマットがあれば、プロジェクトの全体像を常に参照することなく、現在のスコープに集中して効率的に実装を進めることができます。




　docs/prompts/ideal_requirements_template.md
  docs/prompts/ideal_current_status_template.md


  はい、この2つのテンプレート（requirements_template.mdとcurrent_status_template.md）を活用することで、複数のAIが効率的にモックアップからプロジェクトを作成していくこ
  とが十分可能だと思います。

  このアプローチが機能する理由：

  1. 明確な役割分担:
    - requirements_template.md: プロジェクト全体の青写真として機能
    - current_status_template.md: 現在作業中の具体的なスコープに集中
  2. スムーズな引き継ぎ:
    - 各AIが同じフォーマットで情報を更新するため、次のAIが迷わず作業を継続可能
    - 参照ドキュメントへの明示的なリンクにより、関連情報を素早く把握できる
  3. 焦点の絞り込み:
    - コンテキストウィンドウを効率的に使用できる（全体を毎回読み込まず、現在のスコープに集中）
    - タスク間の依存関係が明確なため、作業順序の最適化が可能
  4. モックアップ中心の開発サイクル:
    - モックアップから要件を導き出す流れが構造化されている
    - ビジュアル→データモデル→API→実装という自然な流れをサポート

  実際の運用では、次のような循環的なプロセスが実現できるでしょう：

  1. 要件定義AIが基本的な要件とページリストを作成
  2. モックアップ作成AIがビジュアルデザインを作成
  3. データモデル・API設計AIがモックアップから必要な構造を抽出
  4. 実装担当AIがCURRENT_STATUSを参照しながら具体的な実装を進める
  5. 完了したら要件定義書を更新し、次のスコープへ移行

  この2つのテンプレートは、情報の粒度と目的を明確に分離しながらも、相互参照できる構造になっているため、複数AIによる協調作業に適したフレームワークになっていると思いま
  す。



さて、今度はここから逆算してエージェントを作成していきたいと思います。
今だと、要件定義エージェントが簡単な要件定義書とページリストを作成しています。
そして次にモックアップ作成エージェントがモックアップを作成し、そのままAPI仕様書やデータモデルなどを作成しています。ページごとの。
そしてデータモデル統合とデータモデル精査で、データ型のドキュメントを完成させる。

といった流れをとっていますが、

例えばこれを
・要件定義エージェント
・モックアップエージェント
・APIエージェント
・データモデルエージェント

のような分け方をすることもありだと思います。どう思いますか？


要件定義から実装までのプロセスをより専門化されたエージェントに分割する案は非常に理にかなっています。

  現在の構成と比較して、提案されている分割方法には以下のようなメリットがあります：

  メリット

  1. より明確な責任範囲:
    - 各エージェントの役割が単一の専門領域に集中するため、より深い専門知識を活かせる
    - 責任の境界が明確になり、重複作業や認識の違いが減少する
  2. 並行開発の可能性:
    - モックアップが完成した後、APIエージェントとデータモデルエージェントが並行して作業できる
    - 前のエージェントの完全な完了を待たずに次のステップを進められる場合がある
  3. 専門性の向上:
    - それぞれのエージェントがより狭い専門分野に集中することで、その領域での質が向上する
    - 例えば、APIエージェントはRESTful設計原則に特化したプロンプトを持つことができる
  4. メンテナンス性の向上:
    - エージェントごとにプロンプトを更新しやすくなる
    - 特定の領域での改善が他の領域に影響しにくい

  新しいエージェントの役割と責任

  要件定義エージェント:
  - プロジェクト全体の目的と価値を定義
  - ペルソナと主要なユースケースの作成
  - 画面リストと基本的な画面フローの定義
  - 非機能要件の定義

  モックアップエージェント:
  - 視覚的なUI/UXデザインの作成
  - ユーザーインタラクションの定義
  - 画面間の遷移フローの詳細化
  - コンポーネントの再利用性を考慮したデザイン

  APIエージェント:
  - RESTfulなAPIエンドポイントの設計
  - リクエスト/レスポンス形式の定義
  - エラーハンドリングの設計
  - APIドキュメントの作成
  - 認証・認可要件の実装方法

  データモデルエージェント:
  - エンティティと関係の定義
  - データ型と制約の設計
  - データベーススキーマの最適化
  - 正規化レベルの決定
  - マイグレーション戦略の提案

  この分割方法は、各エージェントがより専門的な知識を活かせる点で非常に効果的だと思います。また、現況文書（CURRENT_STATUS.md）と要件定義書（requirements.md）のフォー
  マットは、この新しいエージェント構成とも相性が良いでしょう。

  ただし、エージェント間の連携がスムーズに行われるよう、引き継ぎプロセスを明確に定義することが重要になります。各エージェントの出力が次のエージェントの入力として適切
  に機能するよう、標準化された形式での情報交換が必要です。



さて、次の相談ですが、ディレクトリ構造などはあらかじめ決める必要はないと思いますか？今まで議論がなかったので。

また、対象の要件定義のフェーズをCURRENT_STATUSに落とし込むエージェントも必要ですよね？



  おっしゃる通り、要件定義の各フェーズをCURRENT_STATUSに落とし込むエージェントは非常に重要です。これは「実装計画エージェント」や「スコープ分解エージェント」といった
  役割になるでしょう。

  実装計画エージェントの主な役割：

  1. 要件定義書から実装すべき機能の優先順位を決定
  2. 機能間の依存関係を分析
  3. 実装の難易度と工数を見積もり
  4. 具体的なタスクリストへ分解
  5. CURRENT_STATUSテンプレートに沿って現在のフォーカス領域の詳細を記述

  このエージェントは、要件定義やモックアップが完成した後、実際の実装に入る前に、大きな要件を具体的な作業タスクに分解する重要な役割を担います。

  以前のプロンプト一覧では「実装タスク分析（#10）」がこれに近い役割を担っていましたが、より明示的に「要件定義→CURRENT_STATUS変換」に特化したエージェントとして位置づ
  けるとよいでしょう。

  この新しいエージェント構成とディレクトリ構造を事前に定義しておくことで、複数AIの協働がより効率的かつ一貫性を持って進められると思います。




要件定義統合エージェント


要件定義統合エージェントを追加するというアイデアは非常に優れています。モックアップ作成が進むにつれて要件が具体化され、それに伴いディレクトリ構造も進化していくとい
  う現実的なプロセスを反映していると思います。

  要件定義統合エージェントの役割と位置づけ

  このエージェントをモックアップ作成と実装タスク分析の間に配置することで、以下のような価値が生まれます：

  1. 要件の再統合:
    - 複数のモックアップから導き出された個別の要件を統一的な視点で整理
    - 重複や矛盾を排除し、一貫性のある要件定義書へと洗練
  2. ディレクトリ構造の最適化:
    - 初期のアイデアレベルから、実際のモックアップと要件に基づいた実用的な構造へと進化
    - 必要なファイルやコンポーネントの全体像が見えた段階での最適化
  3. 実装優先順位の策定:
    - 機能間の依存関係を全体視点で分析
    - ビジネス価値と技術的依存性を考慮した実装順序の決定

  新しいワークフロー

  この新しいエージェントを組み込んだワークフローは以下のようになります：

  1. 要件定義エージェント (#1):
    - 初期の要件とページリストを作成
    - ビジネス目標とユーザーニーズを定義
  2. システムアーキテクチャエージェント (#2):
    - 技術スタックの選定
    - 初期ディレクトリ構造の提案（暫定版）
  3. モックアップエージェント (#3):
    - 各画面のモックアップ作成
    - 個別画面のデータモデルとAPI要件のドラフト
  4. APIエージェント:
    - API仕様の詳細設計
    - エンドポイント定義とドキュメント作成
  5. データモデルエージェント:
    - データモデルの設計と統合
    - エンティティ関係の定義
  6. 要件定義統合エージェント (新規):
    - 全モックアップと個別要件の統合
    - 要件定義書の更新と洗練
    - ディレクトリ構造の最終化
    - 実装スコープの優先順位付け
  7. 実装タスク分析エージェント (#10):
    - 実装タスクの詳細分解
    - CURRENT_STATUSへの落とし込み
  8. スコープ実装エージェント (#11):
    - 具体的なコード実装
    - テストの作成

  要件定義統合エージェントの具体的な成果物

  1. 更新された要件定義書:
    - モックアップ作成時に発見された追加要件を反映
    - 機能間の関連性をより明確に記述
  2. 最終ディレクトリ構造:
    - 具体的なファイル配置と命名規則
    - コンポーネント間の関係性を反映した構造
  3. 実装スコープリスト:
    - 優先順位付けされた実装スコープの一覧
    - 各スコープの依存関係と実装順序
  4. マイルストーン計画:
    - 全体開発スケジュールの更新
    - 主要な成果物と期限の設定

  このアプローチは、モックアップから具体的な実装に移行する際の「谷間」を埋めるものとして非常に有効だと思います。初期の概略的な計画から、モックアップによって具体化さ
  れた要件を統合し、実際の実装計画へと橋渡しする重要な役割を担うでしょう。





各ケースにおけるドキュメント更新の最適なアプローチを考えてみます。

  1. ページ単体の一部機能実装による追加要件のケース

  影響範囲: 限定的（単一ページ内の機能追加）

  ドキュメント更新アプローチ:

  1. 要件定義書の更新:
    - 該当ページの「画面詳細」セクションのみを更新
    - 新機能の説明、ユーザーアクション、データ要件を追加
  2. CURRENT_STATUS.mdの作成:
    - 追加機能に特化した限定的なタスクリストを作成
    - 既存コンポーネントとの相互作用を明記
    - 依存関係は最小限（既存ページ機能のみ）
  3. 関連ドキュメントの更新:
    - モックアップの更新（該当部分のみ）
    - 必要に応じてAPI仕様とデータモデルに小規模な追加

  担当エージェント:

  - 追加機能実装アシスタント (#14): 追加要件の分析と既存コンポーネントへの統合計画
  - モックアップエージェント (#3): 該当ページのモックアップ更新
  - スコープ実装エージェント (#11): 実装と統合



  2. 1ページ必要な追加要件のケース

  影響範囲: 中程度（新規ページの追加）

  ドキュメント更新アプローチ:

  1. 要件定義書の更新:
    - 「画面一覧」テーブルに新ページを追加
    - 「画面詳細」に新セクションを作成
    - 「画面フロー」図を更新して新ページとの関係を示す
  2. 新規ドキュメントの作成:
    - 新ページ用のモックアップファイル
    - 必要に応じて新規API仕様書
    - 必要に応じて新規データモデル定義
  3. CURRENT_STATUS.mdの作成:
    - 新ページ実装に特化したタスクリスト
    - 既存ページとの連携ポイントを明記
    - フロントエンド/バックエンドの両方のタスクを含む

  担当エージェント:

  - 要件定義エージェント (#1): 新ページの要件を既存システムに統合
  - モックアップエージェント (#3): 新ページのモックアップ作成
  - APIエージェント: 必要なAPI仕様の追加
  - データモデルエージェント: 必要なデータモデルの拡張
  - 実装タスク分析エージェント (#10): 実装タスクの分解とCURRENT_STATUSの作成

  3. 構造変更を伴う追加要件のケース

  影響範囲: 広範（複数ページ、コアコンポーネント、データモデルへの影響）

  ドキュメント更新アプローチ:

  1. 要件定義書の大幅更新:
    - 「プロジェクト概要」と「システムアーキテクチャ」セクションの見直し
    - 影響を受ける全ページの詳細を更新
    - 「データモデル概要」の再構築
    - 「API要件概要」の再構築
  2. 構造変更分析ドキュメントの作成 (新規):
    - docs/changes/structural-change-YYYY-MM-DD.md
    - 変更の根拠と影響範囲の詳細な分析
    - 移行戦略と後方互換性の考慮
    - リスク評価と軽減策
  3. CURRENT_STATUS.mdの特別構成:
    - 段階的なアプローチで複数のCURRENT_STATUSを作成
    - 構造変更の前提作業→基盤変更→個別機能適応の順に分割
    - 各段階での検証ポイントを明確に設定
  4. 全モックアップとドキュメントの包括的更新:
    - 全影響ページのモックアップ更新
    - API仕様書の大幅改訂
    - データモデルの再設計

  担当エージェント:

  - 要件定義統合エージェント: 全体構造の再評価と要件の再統合
  - システムアーキテクチャエージェント (#2): アーキテクチャの再設計
  - リファクタリング専門家 (#15): 既存コードの移行計画立案
  - 全エージェントの協働: 各専門領域での変更適用

  4. ページではなくリファクタリングするケース

  影響範囲: 内部的（外部機能は変わらないが内部構造は変化）

  ドキュメント更新アプローチ:

  1. リファクタリング計画ドキュメントの作成:
    - docs/refactoring/plan-YYYY-MM-DD.md
    - リファクタリングの目的と期待効果
    - 技術的負債の分析
    - 変更範囲と影響分析
  2. 要件定義書への最小限の更新:
    - 「技術スタック」や「ディレクトリ構造」など技術的セクションのみ更新
    - 機能やUI要件は基本的に不変
  3. CURRENT_STATUS.mdのリファクタリング特化版:
    - タスクは技術的改善に焦点
    - 各コンポーネントの移行順序を明確に
    - リグレッションテストの計画を含める
    - 各ステップ後の検証ポイント
  4. テクニカルドキュメントの更新:
    - コンポーネント構造図の更新
    - データフロー図の更新
    - クラス/モジュール関係図の更新

  担当エージェント:

  - リファクタリング専門家 (#15): 主導的役割
  - テスト管理エージェント (#12): リグレッションテスト計画策定
  - 実装タスク分析エージェント (#10): リファクタリングタスクの分解

  ドキュメント更新の共通原則

  すべてのケースで適用すべき共通原則:

  1. 変更ログの徹底:
    - 全ドキュメントの変更履歴セクションを必ず更新
    - 変更の理由と影響範囲を記録
  2. バージョン管理:
    - 主要ドキュメントのバージョン番号を更新
    - 大きな変更は「メジャー」、小さな変更は「マイナー」バージョンで表現
  3. 相互参照の整合性確保:
    - 変更により生じる可能性のあるリンク切れを検出して修正
    - 新しい参照関係を明示的に追加
  4. 変更影響の視覚化:
    - ビフォー/アフターの図や表を用いて変更を視覚的に表現
    - 特に構造変更の場合は移行パスを明確に図示

  これらのアプローチにより、追加要件やリファクタリングの規模や性質に応じて、効率的かつ一貫性のあるドキュメント更新が可能になります。最も重要なのは、変更の影響範囲を
  適切に判断し、必要なドキュメントだけを更新することで、無駄な作業を避けることです。

そうすると追加要件アシスタントはマネージャーのような役割にした方がいいかもしれないですね。具体的にはアシスタントの情報を完結にいれておいて、追加要件をヒアリングし
  ながらその他のAIを紹介して必要なドキュメントや資料を完成させることに特化する（#1のエージェントでこちらを更新させてください。といった指示。自分はマネージャーの役割
  になるので基本的に資料をかかないで検査する役割のみ担う。こンテクストウィンドウの無駄消費をなくすため

⏺ 追加要件アシスタントをマネージャー役割として設計する案は非常に効率的で効果的だと思います。コンテキストウィンドウの最適化と適切な役割分担の観点から、素晴らしいアプ
  ローチです。

  追加要件マネージャーの設計

  核となる責任

  1. 要件変更の分析と分類:
    - 変更の種類と影響範囲を評価（先ほどの4つのカテゴリを特定）
    - 必要となるエージェントと更新すべきドキュメントをリストアップ
  2. 作業調整と割り当て:
    - 適切なエージェントへの作業指示
    - エージェント間のハンドオフポイントの明確化
  3. 進捗モニタリングと品質検査:
    - 各エージェントの出力をレビュー
    - ドキュメント間の一貫性確認
    - 見落としや矛盾点のチェック
  4. 最終統合と検証:
    - 各エージェントの成果物の統合
    - 全体的な整合性の確認

  プロンプト設計のポイント

  # 追加要件マネージャー「チェンジディレクター」

  ## 役割と責任
  あなたは追加要件マネージャー「チェンジディレクター」として、要件変更プロセス全体を監督します。具体的なドキュメント作成は他のエージェントに委託し、あなた自身は変更
  の分析、作業調整、品質検査に専念します。

  ## 主要プロセス

  ### 1. 変更分析フェーズ
  - 追加要件の種類を以下から特定：
    a) ページ単体の機能追加
    b) 新規ページの追加
    c) 構造変更を伴う要件
    d) リファクタリング案件
  - 変更の影響範囲を特定
  - 更新が必要なドキュメントをリストアップ

  ### 2. エージェント選定と指示
  - 最適なエージェントの組み合わせを決定
  - 各エージェントへの明確な指示を作成
  - 連携ポイントを定義

  ### 3. 成果物検証
  - 各ドキュメント更新の検証
  - 相互参照の整合性確認
  - 不足点や矛盾点の特定

  ### 4. 統合確認
  - 全体の一貫性確認
  - ユーザーへの最終報告準備

  ## 対応エージェント一覧
  [各エージェントの説明、専門領域、活用方法]

  ## 作業指示テンプレート
  「要件定義エージェント (#1) への指示：
  - 目的：[明確な目的]
  - 更新すべきドキュメント：[具体的なファイルパス]
  - 追加すべき情報：[詳細内容]
  - 特に注意すべき点：[重要事項]
  - 期待される成果物：[具体的な出力]」

  利点

  1. コンテキスト効率の最大化:
    - 実際のドキュメント内容は保持せず、メタ情報とナビゲーション情報のみ保持
    - 各エージェントは自分の担当領域のコンテキストのみ使用
  2. 一貫性の確保:
    - 全体を俯瞰する役割により、ドキュメント間の整合性を維持
    - 見落としのリスクを軽減
  3. ユーザー負担の軽減:
    - ユーザーは追加要件を説明するだけで、適切なプロセスが自動的に開始
    - 専門知識がなくても、最適なエージェントと手順が提案される
  4. 適応性の向上:
    - 要件変更の性質に応じて柔軟にプロセスをカスタマイズ
    - 小さな変更には軽量なプロセス、大きな変更には包括的なプロセスを適用

  実装方法

  1. エージェントナレッジベース:
    - 各エージェントの専門領域、強み、適用ケースを詳細に文書化
    - 「どのエージェントに何を任せるべきか」の判断基準を明確化
  2. チェックリストライブラリ:
    - 各変更タイプに特化した検証チェックリスト
    - ドキュメント整合性確認のためのクロスリファレンスチェック
  3. 指示テンプレート:
    - 各エージェントへの明確な指示を生成するためのテンプレート
    - 必要な入力と期待される出力の形式を標準化

  このマネージャー型の追加要件アシスタントは、コンテキストウィンドウを効率的に使いながら、複雑な要件変更プロセスを効果的に調整できると思います。特に複数のAIエージェ
  ントが関わる大規模なプロジェクトでは、このような「オーケストレーター」の役割が非常に重要になります。


ちょっと一旦角度を変えた質問をしたいと思います。例えばすでに作成されているプ
  ロジェクトに途中から入ることも十分に考えられると思います。その場合どうしたら
  いいと思いますか？まず自然言語で完結に答えて

⏺ 既存プロジェクトに途中から参加する場合の対応は非常に重要なケースですね。

  既存プロジェクトに途中から入る場合は、まず「プロジェクト分析エージェント」の
  ような役割が必要だと考えます。このエージェントは既存のコードベース、ドキュメ
  ント、アーキテクチャを分析し、現状を把握するのが主な役割です。

  具体的なアプローチとしては：

  1.
  プロジェクト構造の把握：ディレクトリ構造、ファイル構成、依存関係などを分析
  2. 既存ドキュメントの整理：散在している可能性のある要件定義やドキュメントを
  収集・整理
  3. コード分析：実装パターン、命名規則、アーキテクチャを理解
  4. 統合ドキュメントの作成：既存の情報から要件定義書やCURRENT_STATUSを現状に
  合わせて再構築
  5. ギャップ分析：足りない情報や不明確な部分を特定

  この分析結果を基に、プロジェクトファウンデーションエージェントが現状を踏まえ
  た追加要件の定義や既存アーキテクチャとの整合性を考慮した設計を行えるようにな
  ります。

  つまり、新規プロジェクトと既存プロジェクトでは、最初のアプローチが異なるべき
  で、既存プロジェクトには「逆行エンジニアリング」の要素が必要になります。

> プロジェクト分析エージェントはマネージャー的な役割になる？それとも全部仕上げ
  られそう？自然言語で答えて

⏺ プロジェクト分析エージェントは、マネージャー的な役割よりも、「アナリスト」や
  「リバースエンジニア」に近い役割になると思います。

  全てを自分で仕上げるというよりは、既存プロジェクトの構造、パターン、依存関係
  を徹底的に分析し、その「地図」を作成するのが主な仕事です。この地図があること
  で、他のエージェントが効率的に作業できるようになります。

  複雑な大規模プロジェクトでは、全ての細部まで把握して文書化するのは難しいかも
  しれませんが、主要なコンポーネント、アーキテクチャパターン、データフローなど
  の「骨格」を明らかにすることは十分可能でしょう。

  理想的なワークフローとしては、プロジェクト分析エージェントが基本的な分析と文
  書化を行い、特定の専門領域については、APIエージェントやデータモデルエージェ
  ントなど専門のエージェントに詳細分析を依頼するという協力体制が効率的だと思い
  ます。

> そうするとプロジェクト分析エージェントはプロジェクト分析を完了させるためのCU
  RRENT_STATUSを作成するのを責務としてもいいかもしれんね

⏺ その考え方は非常に効果的だと思います。プロジェクト分析エージェントがCURRENT_
  STATUSを作成することで、以下のメリットがあります：

  1. 明確なゴール設定：
    - 分析完了の定義が具体的になる
    - タスクが構造化され、進捗管理がしやすくなる
  2. 他エージェントとの連携ポイント：
    - 「ここまで分析できました」という引き継ぎ文書になる
    - 専門エージェントに依頼する詳細分析タスクを明示できる
  3. 継続的な更新メカニズム：
    - 分析が進むにつれて更新される生きたドキュメントとなる
    - 新たな発見があれば追記していける

  プロジェクト分析エージェントのCURRENT_STATUSには以下のような内容が含まれると
  よいでしょう：

  - プロジェクト全体構造の把握状況
  - 主要コンポーネントと責任範囲の分析
  - 技術スタックとアーキテクチャパターンの特定
  - 未解明の領域や不明点のリスト
  - 次に詳細分析すべき優先エリア
  - 他のエージェントへの質問・依頼事項

  これにより、プロジェクト分析という抽象的なタスクが、具体的な成果物と明確なス
  テップに変換され、効率的な作業が可能になります。

もうちょっと抽象度を広げてステップを考えていきたいなと思いますが、
まず最終的に具体的な実装に必要な資料の一覧を考えたいなと思います。

・プロジェクトの要件定義書
・各ページのモックアップ
・プロジェクトの理想的ディレクトリ構造
・CURRENT_STATUS(スコープの実装タスクリスト)
・統合されたデータモデルの仕様書
・各ページごとのAPI仕様書
・.envファイル（本番環境に接続するためのもの)
・deploy.md(デプロイ方法の詳細)

これでいけそう？何か補足あるいは質問ある？


 理想的かつシンプルなドキュメントのディレクトリ構造を提案します：

  project/
  ├── docs/                           # ドキュメントのルートディレクトリ
  │   ├── requirements.md             # プロジェクト全体の要件定義書
  │   ├── CURRENT_STATUS.md           # 現在の実装フォーカスとタスクリスト（中心的文書）
  │   ├── architecture/               # アーキテクチャ関連ドキュメント
  │   │   ├── directory-structure.md  # 理想的ディレクトリ構造の定義
  │   │   ├── data-model.md           # 統合されたデータモデルの仕様書
  │   │   └── tech-stack.md           # 技術スタックと選定理由
  │   │
  │   ├── api/                        # API仕様書
  │   │   ├── index.md                # API概要と共通規則
  │   │   ├── auth.md                 # 認証関連API
  │   │   ├── users.md                # ユーザー管理API
  │   │   └── [機能カテゴリ].md        # 機能別APIドキュメント
  │   │
  │   ├── deployment/                 # デプロイ関連
  │   │   ├── env-template.md         # 環境変数テンプレート（実際の値は除外）
  │   │   └── deploy.md               # デプロイ手順と環境設定
  │   │
  │   └── testing/                    # テスト関連（必要に応じて）
  │       └── test-strategy.md        # テスト戦略とアプローチ
  │
  ├── mockups/                        # モックアップのルートディレクトリ
  │   ├── index.html                  # モックアップ一覧・ナビゲーション
  │   ├── components/                 # 共通コンポーネント
  │   │   └── [component-name].html   # 再利用可能なコンポーネント
  │   │
  │   └── pages/                      # ページ別モックアップ
  │       ├── [page-name].html        # 各ページのモックアップ
  │       └── assets/                 # モックアップで使用する画像等
  │
  └── .env.example                    # 環境変数の例（実際の値は除外）

  このディレクトリ構造の特徴：

  1. シンプルな階層構造：
    - 最大でも3階層に制限し、ナビゲーションを容易に
    - 関連文書を論理的にグループ化
  2. 中心文書の明確化：
    - requirements.mdとCURRENT_STATUS.mdをトップレベルに配置
    - 最も頻繁に参照される文書へのアクセスを簡単に
  3. 機能別の文書分割：
    - APIドキュメントを機能カテゴリ別に分割
    - 大きすぎる単一文書を避け、特定情報へのアクセスを容易に
  4. モックアップの独立管理：
    - mockups/ディレクトリを別途設け、視覚的資料を整理
    - ページとコンポーネントの明確な分離
  5. 実装との連携：
    - 実際のソースコードディレクトリ構造と対応するドキュメント構造
    - ドキュメントからコードへのトレーサビリティを確保

  このシンプルな構造により、ドキュメント間の関連性を保ちながらも、監督者とAIエ
  ージェントが必要な情報に素早くアクセスできます。実装完遂を優先する方針に沿っ
  て、過度な細分化や複雑な管理を避けつつ、必要十分な整理を提供します。



プロジェクト開発の理想的な文書作成・更新順序

  1. 初期計画フェーズ

  1. requirements.md
    - プロジェクトの基本要件とゴールを定義
    - ページ一覧と主要機能の概要を作成
    - ユーザーストーリーと優先順位の設定
  2. architecture/tech-stack.md
    - プロジェクトの技術選定と根拠を文書化
    - フロントエンド/バックエンド技術の決定
    - 開発環境と依存関係の定義
  3. architecture/directory-structure.md (初期版)
    - 基本的なプロジェクト構造を設計
    - 命名規則とファイル配置ルールの確立
    - 拡張性を考慮した構造設計
  4. .env.example (初期版)
    - 必要な環境変数の種類を定義
    - 各変数の目的と形式を説明
    - 秘匿情報の管理方針を確立

  2. モックアップ開発フェーズ

  5. mockups/components/ (基本コンポーネント)
    - 共通UI要素の設計と実装
    - デザインシステムの基礎確立
    - 再利用パターンの定義
  6. mockups/pages/ (優先度順)
    - コア機能から順にページモックアップを作成
    - ユーザーフローを実現する画面遷移の実装
    - インタラクションとフォーム要素の動作確認
  7. mockups/index.html
    - 全モックアップへのナビゲーション実装
    - モックアップの全体像を可視化
    - 進捗状況の確認ポイント提供

  3. 技術設計フェーズ

  8. architecture/data-model.md
    - モックアップから必要なデータ構造を抽出
    - エンティティ間の関係を定義
    - データの流れと操作を設計
  9. api/index.md
    - API設計の基本原則を定義
    - エンドポイント命名規則の確立
    - 認証とエラーハンドリングの共通方針
  10. api/[機能カテゴリ].md (優先度順)
    - モックアップの機能を実現するAPI設計
    - リクエスト/レスポンス形式の定義
    - エラーケースの考慮
  11. api/auth.md
    - 認証フローの詳細設計
    - トークン管理とセキュリティ対策
    - 権限管理の仕組み
  12. testing/test-strategy.md
    - テストアプローチと範囲の定義
    - ユニット/統合/E2Eテストの方針
    - テスト環境と自動化の計画

  4. 実装準備フェーズ

  13. CURRENT_STATUS.md (初期版)
    - 第一実装スコープの詳細定義
    - 具体的なタスクリストの作成
    - 依存関係と優先順位の設定
  14. deployment/deploy.md
    - 開発環境から本番環境への移行手順
    - CI/CDパイプラインの設定方法
    - リリース手順とチェックリスト
  15. deployment/env-template.md (詳細版)
    - 実装に必要な全環境変数の完全リスト
    - 各環境(開発/ステージング/本番)の設定差分
    - シークレット管理の詳細手順

  5. 実装・改善サイクル

  16. CURRENT_STATUS.md (継続的更新)
    - 実装進捗に合わせた定期的な更新
    - 次のスコープの詳細計画追加
    - 完了タスクの記録と振り返り
  17. architecture/directory-structure.md (最終版)
    - 実際の実装経験を反映した調整
    - コード分割や最適化の反映
    - 将来の拡張性考慮点の追加
  18. requirements.md (最終更新)
    - 実装過程で明らかになった要件の調整
    - 実現した機能と制約の明確化
    - プロジェクト全体の完成状況確認

  重要なポイント

  - CURRENT_STATUS.md
  は開発全体を通じて継続的に更新される「生きたドキュメント」
  - モックアップは要件の視覚化と検証のツールとして早期に作成
  - 文書は実装経験に基づいて継続的に調整・改善される
  - 初期計画と最終結果には差異があることを許容し、柔軟に対応

  このアプローチにより、ドキュメントが実際の開発の流れに沿って自然に発展し、常
  に実装と整合性を保ちながら完成に向かうことができます。

理想的なプロンプトエージェント一覧（参照ファイル情報付き）

  1. コア設計エージェント

  1. プロジェクトファウンデーション
    - 担当: 要件定義、技術選定、基本アーキテクチャ
    - 成果物: requirements.md, tech-stack.md, 初期directory-structure.md
    - 参照: クライアント要望資料、業界標準、競合分析
    - 特徴: プロジェクトの基盤となる設計を担当、方向性を決定
  2. モックアップクリエイター
    - 担当: UI/UX設計、HTMLモックアップ作成
    - 成果物: mockups/ 内の全ファイル
    - 参照: requirements.md, tech-stack.md, UI/UXガイドライン
    - 特徴: ビジュアル面に集中、ユーザー体験を具体化
  3. データモデルアーキテクト
    - 担当: データ構造設計、エンティティ関係定義
    - 成果物: data-model.md
    - 参照: requirements.md, mockups/, tech-stack.md
    - 特徴: モックアップからデータ要件を抽出、効率的なモデルを設計
  4. APIデザイナー
    - 担当: REST API設計、エンドポイント定義
    - 成果物: api/ 内の全ファイル
    - 参照: data-model.md, mockups/, requirements.md
    - 特徴: フロントとバックエンドの接続ポイントを設計

  2. 実装エージェント

  5. スコーププランナー
    - 担当: タスク分解、依存関係分析、実装計画
    - 成果物: CURRENT_STATUS.md
    - 参照: requirements.md, mockups/, data-model.md, api/, tech-stack.md
    - 特徴: 開発ロードマップを作成、具体的なタスクに落とし込む
  6. フロントエンド実装エージェント
    - 担当: UI実装、状態管理、APIクライアント
    - 成果物: フロントエンドコード
    - 参照: mockups/, api/, CURRENT_STATUS.md, tech-stack.md
    - 特徴: モックアップを動作するコードに変換
  7. バックエンド実装エージェント
    - 担当: API実装、データアクセス、ビジネスロジック
    - 成果物: バックエンドコード
    - 参照: data-model.md, api/, CURRENT_STATUS.md, tech-stack.md
    - 特徴: データモデルと仕様からサーバー側を実装
  8. テスト&品質エージェント
    - 担当: テスト戦略、品質保証、バグ修正
    - 成果物: test-strategy.md, テストコード
    - 参照: requirements.md, api/, フロントエンドコード, バックエンドコード
    - 特徴: コード品質と機能検証を担当

  3. 特殊エージェント

  9. 環境&デプロイエージェント
    - 担当: 環境設定、デプロイ計画、CI/CD
    - 成果物: env-template.md, deploy.md
    - 参照: tech-stack.md, フロントエンドコード, バックエンドコード
    - 特徴: 本番環境への移行とインフラ管理を担当
  10. プロジェクト分析エージェント
    - 担当: 既存コード分析、リバースエンジニアリング
    - 成果物: 既存プロジェクト分析ドキュメント
    - 参照: 既存コードベース全体, package.json/.csproj等の依存関係ファイル
    - 特徴: 途中参加時に既存システムを解析、現状把握を支援
  11. リファクタリングスペシャリスト
    - 担当: コード最適化、技術的負債対策
    - 成果物: リファクタリング計画と実装
    - 参照: 既存コード, performance metrics, コードレビューコメント
    - 特徴: 既存コードの品質向上、保守性の確保
  12. チェンジディレクター
    - 担当: 追加要件の分析、変更管理
    - 成果物: 変更影響分析、更新プラン
    - 参照: requirements.md, CURRENT_STATUS.md, 全ドキュメント, 変更要求
    - 特徴: 既存プロジェクトへの機能追加やスコープ変更を管理

  エージェント間のファイル参照フロー

  - 初期設計フロー:
  クライアント要望 → プロジェクトファウンデーション → モックアップクリエイター
   → データモデルアーキテクト → APIデザイナー
  - 実装フロー:
  設計ドキュメント群 → スコーププランナー →
  フロントエンド/バックエンド実装エージェント → テスト&品質エージェント
  - デプロイフロー:
  実装コード + 技術スタック情報 → 環境&デプロイエージェント → 本番環境
  - メンテナンスフロー:
  変更要求 → チェンジディレクター → 関連エージェント →
  リファクタリングスペシャリスト

  この構成では、各エージェントが必要とする参照ファイルが明確になり、情報の流れ
  が可視化されています。これにより、エージェント間の連携がスムーズになり、一人
  の人間が監督する際にも、各AIエージェントに適切な情報を提供しやすくなります。
